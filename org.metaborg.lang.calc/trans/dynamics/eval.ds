module dynamics/eval
imports src-gen/ds-signatures/Calc-sig dynamics/natives
signature
  sorts Value
  sort aliases
    Env = Map(ID, Value)
  constructors
    NumV  : Int -> Value
    BoolV : Bool -> Value
    ClosV : ID * Exp * Env -> Value
  variables
    v : Value
  components
    E : Env
  arrows
    Program -init-> Value
    Exp --> Value
    eqv(Value, Value) --> Bool
    ift(Value, Exp, Exp) --> Value
rules
  Program(e) -init-> v
  where E {} |- e --> v
  
  E |- Var(x) --> E[x]
  
  E |- Fun([x], e) --> ClosV(x, e, E)
  
  E |- Let(x, v1, e2) --> v
  where E {x |--> v1, E} |- e2 --> v
  
  App(ClosV(x, e, E), v_arg) --> v
  where E {x |--> v_arg, E} |- e --> v
  
  Num(i) --> NumV(parseI(i)) 
  
  Exp(NumV(i), NumV(j)) --> NumV(expI(i, j))
  Mul(NumV(i), NumV(j)) --> NumV(mulI(i, j)) 
  Div(NumV(i), NumV(j)) --> NumV(divI(i, j))
  Sub(NumV(i), NumV(j)) --> NumV(subI(i, j))
  Add(NumV(i), NumV(j)) --> NumV(addI(i, j))
  
  Lt(NumV(i), NumV(j)) --> BoolV(ltI(i, j))
  
  Eq(v1, v2) --> BoolV(eqv(v1, v2))
  eqv(NumV(i), NumV(j)) --> eqI(i, j)
  
  False() --> BoolV(false)
  True() --> BoolV(true)
  
  If(v1, e2, e3) --> ift(v1, e2, e3)
  
  ift(BoolV(true), e2, _) --> e2
  ift(BoolV(false), _, e3) --> e3
  
//  Not(e) --> If(e, False(), True())
//  And(e1, e2) --> If(e1, e2, False())
//  Or(e1, e2) --> If(e1, True(), e2)
//  Gt(e1, e2) --> Lt(e2, e1)
//  Neq(e1, e2) --> Not(Eq(e1, e2))
  
  